{
    "language": "Solidity",
    "settings": {
      "optimizer": {
        "enabled": false,
        "runs": 200
      }
    },
    "sources": {
      "NFTicket.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract NFTicket is ERC721Enumerable, ERC721URIStorage, Ownable {\n    uint256[4] public categorySupplies; // store the supplies of each category of tickets\n    uint256[4] public categoryPrices; // store the prices for the different category of tickets (calculated in SUN not TRX)\n    uint256 public saleStartTime; // store the start time for ticket sales\n    uint256 public mintLimitPerAddress;\n\n    uint256[4] private categoryStartIds; // Starting tokenId for each category\n    uint256[4] private mintedPerCategory; // Tracks the number of tokens minted in each category\n\n    string[4] public categoryURIs;\n\n    bool public eventCanceled = false; // Indicates if the event has been canceled\n    mapping(uint256 => bool) public ticketInsurance; // Tracks which tickets have insurance\n    mapping(uint256 => uint256) private insuranceCostPaid; // Tracks the insurance cost paid for each ticket\n    mapping(uint256 => uint256) private ticketPricePaid; // Tracks the price paid for each ticket for insurance purposes\n\n    mapping(uint256 => bool) private _redeemedTickets; // store the redeemed tickets so that they cannot be redeemed again\n    mapping(address => uint256) public mintCountPerAddress;\n\n    event TicketRedeemed(uint256 indexed tokenId);\n    event TicketMinted(\n        uint256 indexed categoryId,\n        uint256 indexed tokenId,\n        address indexed minter\n    );\n    event EventStatusChanged(bool canceled);\n    event InsurancePurchased(uint256 indexed tokenId, uint256 cost);\n    event RefundIssued(uint256 indexed tokenId, uint256 amount);\n\n    // in this constructor i am strictly limiting the number of catergories of tickets to ONLY 4\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256[4] memory _categorySupplies,\n        uint256[4] memory _categoryPrices,\n        string[4] memory _categoryURIs,\n        uint256 _saleStartTime,\n        uint256 _mintLimitPerAddress\n    ) ERC721(name, symbol) Ownable(msg.sender) {\n        require(\n            _saleStartTime > block.timestamp,\n            \"Sale start time must be in the future.\"\n        );\n        categorySupplies = _categorySupplies;\n        categoryPrices = _categoryPrices;\n        categoryURIs = _categoryURIs;\n        saleStartTime = _saleStartTime;\n        mintLimitPerAddress = _mintLimitPerAddress;\n\n        // Initialize categoryStartIds based on the supplied categorySupplies\n        uint256 currentStartId = 1;\n        for (uint256 i = 0; i < _categorySupplies.length; i++) {\n            categoryStartIds[i] = currentStartId;\n            currentStartId += _categorySupplies[i];\n        }\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n\n    function mintTicket(\n        uint256 categoryId,\n        uint256 ticketCount\n    ) public payable {\n        require(\n            categoryId >= 0 && categoryId < categorySupplies.length,\n            \"Invalid category\"\n        );\n        require(ticketCount > 0, \"Must mint at least one ticket\");\n        require(block.timestamp >= saleStartTime, \"Sale has not started yet.\");\n        require(!eventCanceled, \"Event is already canceled.\");\n        require(\n            mintCountPerAddress[msg.sender] + ticketCount <=\n                mintLimitPerAddress,\n            \"Minting limit exceeded for this address.\"\n        );\n        require(\n            mintedPerCategory[categoryId] + ticketCount <=\n                categorySupplies[categoryId],\n            \"Category supply exceeded.\"\n        );\n        require(\n            msg.value == categoryPrices[categoryId] * ticketCount,\n            \"Incorrect price.\"\n        );\n\n        for (uint256 i = 0; i < ticketCount; i++) {\n            uint256 tokenId = categoryStartIds[categoryId] +\n                mintedPerCategory[categoryId];\n            mintedPerCategory[categoryId]++;\n            mintCountPerAddress[msg.sender]++;\n            _mint(msg.sender, tokenId);\n\n            string memory selectedURI = categoryURIs[categoryId];\n            _setTokenURI(tokenId, selectedURI);\n\n            ticketPricePaid[tokenId] = categoryPrices[categoryId];\n            emit TicketMinted(categoryId, tokenId, msg.sender);\n        }\n    }\n\n    function redeemTicket(uint256 tokenId) public {\n        require(!eventCanceled, \"Event is already canceled.\");\n        require(ownerOf(tokenId) == msg.sender, \"Caller is not the owner.\");\n        require(!_redeemedTickets[tokenId], \"Ticket already redeemed.\");\n        _redeemedTickets[tokenId] = true;\n        emit TicketRedeemed(tokenId);\n    }\n\n    function isTicketRedeemed(uint256 tokenId) public view returns (bool) {\n        uint256 upperBound = categoryStartIds[categoryStartIds.length - 1] +\n            categorySupplies[categorySupplies.length - 1] -\n            1;\n        require(\n            tokenId > 0 && tokenId <= upperBound,\n            \"Query for nonexistent token.\"\n        );\n        return _redeemedTickets[tokenId];\n    }\n\n    function cancelEvent() public onlyOwner {\n        require(!eventCanceled, \"Event is already canceled.\");\n        eventCanceled = true;\n        emit EventStatusChanged(true);\n    }\n\n    function buyInsurance(uint256 tokenId) public payable {\n        require(\n            msg.sender == ownerOf(tokenId),\n            \"Caller is not the owner of the token.\"\n        );\n        require(!eventCanceled, \"Event is already canceled.\");\n        require(\n            !ticketInsurance[tokenId],\n            \"Insurance already purchased for this ticket.\"\n        );\n\n        uint256 categoryId = determineCategoryId(tokenId);\n        uint256 ticketPrice = categoryPrices[categoryId];\n        uint256 expectedInsuranceCost = (ticketPrice * 20) / 100; // Insurance cost is 20% of the ticket price\n\n        require(\n            msg.value == expectedInsuranceCost,\n            \"Incorrect value for insurance.\"\n        );\n\n        ticketInsurance[tokenId] = true;\n        insuranceCostPaid[tokenId] = msg.value; // Store the insurance cost paid\n        emit InsurancePurchased(tokenId, msg.value);\n    }\n\n    function claimRefund(uint256 tokenId) public {\n        require(eventCanceled, \"Event is not canceled.\");\n        require(\n            ownerOf(tokenId) == msg.sender,\n            \"Caller is not the owner of the ticket.\"\n        );\n        require(ticketInsurance[tokenId], \"Ticket is not insured.\");\n\n        uint256 totalRefundAmount = ticketPricePaid[tokenId] +\n            insuranceCostPaid[tokenId];\n\n        // Reset the insurance and price paid mappings for the tokenId\n        ticketInsurance[tokenId] = false;\n        insuranceCostPaid[tokenId] = 0;\n        ticketPricePaid[tokenId] = 0;\n\n        // Transfer the total refund amount to the owner\n        payable(msg.sender).transfer(totalRefundAmount);\n        emit RefundIssued(tokenId, totalRefundAmount);\n    }\n\n    // Function to retrieve insured token IDs owned by a specific address\n    function getInsuredTokenIds(\n        address _owner\n    ) public view returns (uint256[] memory) {\n        uint256 ownerTokenCount = balanceOf(_owner); // Total tokens owned by the address\n        uint256[] memory tempTokenIds = new uint256[](ownerTokenCount); // Temporary array to store all insured token IDs\n        uint256 insuredCount = 0; // Counter for insured tokens\n\n        for (uint256 i = 0; i < ownerTokenCount; i++) {\n            uint256 tokenId = tokenOfOwnerByIndex(_owner, i); // Get token ID at index i\n            if (ticketInsurance[tokenId]) {\n                // Check if the token ID has insurance\n                tempTokenIds[insuredCount] = tokenId; // Store insured token ID\n                insuredCount++; // Increment the count of insured tokens\n            }\n        }\n\n        uint256[] memory insuredTokenIds = new uint256[](insuredCount); // Final array with the correct size for insured tokens\n        for (uint256 j = 0; j < insuredCount; j++) {\n            insuredTokenIds[j] = tempTokenIds[j]; // Copy insured token IDs to the final array\n        }\n        return insuredTokenIds; // Return the array of insured token IDs\n    }\n\n    function determineCategoryId(\n        uint256 tokenId\n    ) public view returns (uint256) {\n        for (uint256 i = 0; i < categoryStartIds.length; i++) {\n            uint256 startId = categoryStartIds[i];\n            uint256 endId = i < categoryStartIds.length - 1\n                ? categoryStartIds[i + 1] - 1\n                : startId + categorySupplies[i] - 1;\n            if (tokenId >= startId && tokenId <= endId) {\n                return i;\n            }\n        }\n        revert(\"tokenId does not belong to any category\");\n    }\n\n    function getOwnedTokenIds(\n        address _owner\n    ) public view returns (uint256[] memory) {\n        uint256 ownerTokenCount = balanceOf(_owner);\n        uint256[] memory tokenIds = new uint256[](ownerTokenCount);\n\n        for (uint256 i = 0; i < ownerTokenCount; i++) {\n            tokenIds[i] = tokenOfOwnerByIndex(_owner, i);\n        }\n\n        return tokenIds;\n    }\n\n    function getAllMintedTokens() public view returns (uint256[] memory) {\n        uint256 totalTokens = totalSupply(); // Get the total number of tokens minted\n        uint256[] memory tokens = new uint256[](totalTokens);\n\n        for (uint256 i = 0; i < totalTokens; i++) {\n            tokens[i] = tokenByIndex(i);\n        }\n\n        return tokens;\n    }\n\n    function getAllUnmintedTokens() public view returns (uint256[] memory) {\n        uint256 totalTokensPossible = 0;\n        for (uint256 i = 0; i < categorySupplies.length; i++) {\n            totalTokensPossible += categorySupplies[i];\n        }\n\n        uint256[] memory mintedTokens = getAllMintedTokens();\n        bool[] memory isMinted = new bool[](totalTokensPossible + 1); // Assuming token IDs start at 1\n        for (uint256 i = 0; i < mintedTokens.length; i++) {\n            if (mintedTokens[i] <= totalTokensPossible) {\n                // Sanity check\n                isMinted[mintedTokens[i]] = true;\n            }\n        }\n\n        uint256 unmintedCount = totalTokensPossible - mintedTokens.length;\n        uint256[] memory unmintedTokens = new uint256[](unmintedCount);\n        uint256 counter = 0;\n        for (uint256 i = 1; i <= totalTokensPossible; i++) {\n            if (!isMinted[i]) {\n                unmintedTokens[counter++] = i;\n                if (counter == unmintedCount) break; // Found all unminted, exit early\n            }\n        }\n\n        return unmintedTokens;\n    }\n\n    function withdraw() public onlyOwner {\n        uint256 balance = address(this).balance;\n        require(balance > 0, \"No funds available for withdrawal.\");\n\n        // Transfer the entire contract balance to the owner's address.\n        (bool success, ) = owner().call{value: balance}(\"\");\n        require(success, \"Withdrawal failed.\");\n    }\n\n    // Override functions that exist in both ERC721Enumerable and ERC721URIStorage (multiple inheritance)\n\n    function _increaseBalance(\n        address account,\n        uint128 value\n    ) internal override(ERC721, ERC721Enumerable) {\n        super._increaseBalance(account, value);\n    }\n\n    function _update(\n        address to,\n        uint256 tokenId,\n        address auth\n    ) internal override(ERC721, ERC721Enumerable) returns (address) {\n        return super._update(to, tokenId, auth);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    )\n        public\n        view\n        virtual\n        override(ERC721Enumerable, ERC721URIStorage)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function tokenURI(\n        uint256 tokenId\n    ) public view override(ERC721, ERC721URIStorage) returns (string memory) {\n        return super.tokenURI(tokenId);\n    }\n\n    // // Override tokenURI to return a different metadata if the event is canceled\n    // function tokenURI(uint256 tokenId) public view override(ERC721, ERC721URIStorage) returns (string memory) {\n    //     if (eventCanceled) {\n    //         return \"ipfs://<canceled_event_metadata_uri>\"; // Return an empty string or a URI indicating the event is canceled\n    //     }\n    //     return super.tokenURI(tokenId);\n    // }\n}"
      }
    }
  }
  